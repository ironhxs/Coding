# 回溯｜总结

关键：回溯模板、剪枝优化、去重技巧。

## 回溯模板

回溯本质是暴力搜索（穷举），通过递归模拟 N 叉树的遍历。

```cpp
void backtracking(参数) {
    if (终止条件) {
        收集结果;
        return;
    }
    for (选择 : 本层集合) {
        处理节点;           // 做选择
        backtracking(路径, 选择列表);  // 递归
        撤销处理;           // 回溯（撤销选择）
    }
}
```

### Lambda 写法
```cpp
auto backtracking = [&](auto&& self, int start) -> void {
    if (终止条件) { 收集结果; return; }
    for (int i = start; i < n; i++) {
        path.push_back(选择);
        self(self, i + 1);   // 不可重复选：i+1；可重复选：i
        path.pop_back();      // 回溯
    }
};
backtracking(backtracking, 0);
```

## 组合问题分类

| 问题类型 | start 传递 | 去重 | 典型题目 |
|---------|-----------|------|---------|
| 组合（不重复） | i + 1 | 无需 | 77, 216 |
| 可重复选 | i（不加1） | 无需 | 39 |
| 有重复元素不可重复选 | i + 1 | 排序+同层去重 | 40 |
| 多集合组合 | 用 k 控制层 | 无需 | 17 |

## 去重技巧

### 同层去重（树层去重）
适用于候选集有重复元素但结果不能重复的场景：
```cpp
sort(candidates.begin(), candidates.end());  // 必须先排序
for (int i = start; i < n; i++) {
    if (i > start && candidates[i] == candidates[i-1])
        continue;  // 跳过同层重复元素
    // ...
}
```

## 剪枝

- **组合数量剪枝**：已选 path.size() 个，还需 k - path.size() 个，`i <= n - (k - path.size()) + 1`
- **总和剪枝**：`sum + candidates[i] > target` 时跳过

## 复杂度
- 时间：组合问题一般 O(C(n,k)) ~ O(2^n)
- 空间：O(k)~O(n)，递归栈深度

## 易错点
- **回溯必须撤销操作**：push_back 对应 pop_back，sum += 对应 sum -=
- **可重复选元素**：递归传 i 而不是 i+1
- **同层去重**需要先排序，判断 `i > start`（不是 `i > 0`）
- **不同集合间的组合**（如电话号码）不需要 start，用层数 k 控制

## 题目索引（代码与力扣链接）

### 组合
- 77 组合 ― [代码](../../code/回溯/77%20组合.cpp) | [LeetCode](https://leetcode.cn/problems/combinations/)
- 216 组合总和 III ― [代码](../../code/回溯/216%20组合总和%20III.cpp) | [LeetCode](https://leetcode.cn/problems/combination-sum-iii/)
- 17 电话号码的字母组合 ― [代码](../../code/回溯/17%20电话号码的字母组合.cpp) | [LeetCode](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
- 39 组合总和 ― [代码](../../code/回溯/39%20组合总和.cpp) | [LeetCode](https://leetcode.cn/problems/combination-sum/)
- 40 组合总和 II ― [代码](../../code/回溯/40%20组合总和%20II.cpp) | [LeetCode](https://leetcode.cn/problems/combination-sum-ii/)
