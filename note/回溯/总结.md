# 回溯｜总结

关键：回溯模板、剪枝优化、去重技巧。

## 回溯模板

回溯本质是暴力搜索（穷举），通过递归模拟 N 叉树的遍历。

```cpp
void backtracking(参数) {
    if (终止条件) {
        收集结果;
        return;
    }
    for (选择 : 本层集合) {
        处理节点;           // 做选择
        backtracking(路径, 选择列表);  // 递归
        撤销处理;           // 回溯（撤销选择）
    }
}
```

### Lambda 写法
```cpp
auto backtracking = [&](auto&& self, int start) -> void {
    if (终止条件) { 收集结果; return; }
    for (int i = start; i < n; i++) {
        path.push_back(选择);
        self(self, i + 1);   // 不可重复选：i+1；可重复选：i
        path.pop_back();      // 回溯
    }
};
backtracking(backtracking, 0);
```

## 组合问题分类

| 问题类型 | start 传递 | 去重 | 典型题目 |
|---------|-----------|------|---------|
| 组合（不重复） | i + 1 | 无需 | 77, 216 |
| 可重复选 | i（不加1） | 无需 | 39 |
| 有重复元素不可重复选 | i + 1 | 排序+同层去重 | 40 |
| 多集合组合 | 用 k 控制层 | 无需 | 17 |

## 排列问题分类

| 问题类型 | 遍历起点 | 去重 | 典型题目 |
|---------|---------|------|--------|
| 无重复排列 | 0 + used 数组 | 无需 | 46 |
| 有重复排列 | 0 + used 数组 | 排序+同层去重 | 47 |

排列 vs 组合的核心区别：
- **组合**用 start 控制起点，避免重复选取前面的元素
- **排列**每次从 0 开始，用 used 数组跳过已选元素

## 棋盘问题

### N 皇后
逐行放置皇后，用三个布尔数组标记约束：
- `usedV[i]`：列
- `usedL[i-j+n-1]`：左对角线（\ 方向，i-j 相同）
- `usedR[i+j]`：右对角线（/ 方向，i+j 相同）

### 解数独
逐格尝试 1-9，三个约束：行、列、3×3 宫格。**关键剪枝**：某格尝试完所有数字都不行时立即返回 false。

## 去重技巧

### 同层去重（树层去重）
适用于候选集有重复元素但结果不能重复的场景：
```cpp
sort(candidates.begin(), candidates.end());  // 必须先排序
for (int i = start; i < n; i++) {
    if (i > start && candidates[i] == candidates[i-1])
        continue;  // 跳过同层重复元素
    // ...
}
```

### 排列去重
排列中用 `!used[i-1]` 判断同层重复（前一个相同元素未被使用说明是同层回溯后的状态）：
```cpp
if (used[i] || (i > 0 && nums[i-1] == nums[i] && !used[i-1]))
    continue;
```

## 剪枝

- **组合数量剪枝**：已选 path.size() 个，还需 k - path.size() 个，`i <= n - (k - path.size()) + 1`
- **总和剪枝**：`sum + candidates[i] > target` 时跳过

## 复杂度
- 时间：组合问题一般 O(C(n,k)) ~ O(2^n)
- 空间：O(k)~O(n)，递归栈深度

## 易错点
- **回溯必须撤销操作**：push_back 对应 pop_back，sum += 对应 sum -=
- **可重复选元素**：递归传 i 而不是 i+1
- **同层去重**需要先排序，判断 `i > start`（不是 `i > 0`）
- **不同集合间的组合**（如电话号码）不需要 start，用层数 k 控制
- **排列去重**：`!used[i-1]` 表示同层去重，`used[i-1]` 表示同枝去重，两种都能 AC 但效率不同
- **数独回溯**：空格尝试完 1-9 都不行时必须 `return false`，否则会覆盖正确填入的值

## 题目索引（代码与力扣链接）

### 组合
- 77 组合 ― [代码](../../code/回溯/77%20组合.cpp) | [LeetCode](https://leetcode.cn/problems/combinations/)
- 216 组合总和 III ― [代码](../../code/回溯/216%20组合总和%20III.cpp) | [LeetCode](https://leetcode.cn/problems/combination-sum-iii/)
- 17 电话号码的字母组合 ― [代码](../../code/回溯/17%20电话号码的字母组合.cpp) | [LeetCode](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
- 39 组合总和 ― [代码](../../code/回溯/39%20组合总和.cpp) | [LeetCode](https://leetcode.cn/problems/combination-sum/)
- 40 组合总和 II ― [代码](../../code/回溯/40%20组合总和%20II.cpp) | [LeetCode](https://leetcode.cn/problems/combination-sum-ii/)

### 排列
- 46 全排列 ― [代码](../../code/回溯/46%20全排列.cpp) | [LeetCode](https://leetcode.cn/problems/permutations/)
- 47 全排列 II ― [代码](../../code/回溯/47%20全排列%20II.cpp) | [LeetCode](https://leetcode.cn/problems/permutations-ii/)

### 棋盘问题
- 51 N 皇后 ― [代码](../../code/回溯/51%20N%20皇后.cpp) | [LeetCode](https://leetcode.cn/problems/n-queens/)
- 37 解数独 ― [代码](../../code/回溯/37%20解数独.cpp) | [LeetCode](https://leetcode.cn/problems/sudoku-solver/)
