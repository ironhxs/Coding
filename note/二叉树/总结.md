# 二叉树｜总结

关键：递归三要素、统一迭代法、层序遍历模板、DFS vs BFS 选择。

## 遍历方式

### 递归遍历（DFS）
递归三要素（代码随想录精华）：
1. **确定递归函数的参数和返回值**
2. **确定终止条件**
3. **确定单层递归的逻辑**

```cpp
// 前序：中-左-右
void preorder(TreeNode* node) {
    if (!node) return;
    visit(node);           // 中
    preorder(node->left);  // 左
    preorder(node->right); // 右
}
// 中序：左-中-右 | 后序：左-右-中（调整 visit 位置即可）
```

### 统一迭代法（栈 + nullptr 标记）
核心思想：用 nullptr 标记待处理节点，实现前中后序统一模板。

```cpp
// 入栈顺序（栈是后进先出，所以反着写）
// 前序(中左右): 右-左-中-nullptr
// 中序(左中右): 右-中-nullptr-左
// 后序(左右中): 中-nullptr-右-左
while (!st.empty()) {
    auto node = st.top(); st.pop();
    if (node) {
        // 按顺序入栈（反向）
        if (node->right) st.push(node->right);
        st.push(node);
        st.push(nullptr);  // 标记
        if (node->left) st.push(node->left);
    } else {
        node = st.top(); st.pop();
        ret.push_back(node->val);  // 处理
    }
}
```

### 层序遍历（BFS）
模板（代码随想录精华）：一道模板可以解决 10+ 道层序变体题。

```cpp
queue<TreeNode*> que;
que.push(root);
while (!que.empty()) {
    int size = que.size();  // 关键：记录当前层节点数
    for (int i = 0; i < size; i++) {
        auto node = que.front(); que.pop();
        // 处理当前节点
        if (node->left) que.push(node->left);
        if (node->right) que.push(node->right);
    }
    // 一层处理完毕
}
```

## DFS vs BFS 选择

| 场景 | 选择 | 原因 |
|------|------|------|
| 需要逐层处理 | BFS | 天然按层分隔 |
| 求深度/路径 | DFS | 递归天然记录路径 |
| 验证结构性质 | 取决于题目 | 对称性用递归，层级用 BFS |
| 右视图/左视图 | BFS | 每层取边界元素 |

## 二叉搜索树（BST）

### BST 性质
- 左子树所有节点值 < 根节点值 < 右子树所有节点值
- **中序遍历得到有序序列**（核心性质）

### 常用技巧
```cpp
// 中序遍历 + pre 指针：验证BST/求最小差/求众数
TreeNode* pre = nullptr;
void inorder(TreeNode* node) {
    if (!node) return;
    inorder(node->left);
    // 处理 pre 和 node 的关系
    pre = node;
    inorder(node->right);
}
```

### BST 搜索
```cpp
// 利用 BST 性质，不需要遍历整棵树
TreeNode* search(TreeNode* node, int val) {
    if (!node || node->val == val) return node;
    return node->val > val ? search(node->left, val) : search(node->right, val);
}
```

### BST 插入与删除
- **插入**：找到空位置直接插入
- **删除**（难点）：
  1. 叶子节点：直接删除
  2. 单子树：子树替换
  3. 双子树：用左子树最大值或右子树最小值替换，再删除替换节点

## 最近公共祖先（LCA）

### 普通二叉树 LCA
后序遍历，返回是否包含 p/q，第一个同时包含两者的节点即为 LCA。

### BST 的 LCA
利用 BST 性质：
- p, q 都在左子树 → 往左找
- p, q 都在右子树 → 往右找
- p, q 分居两侧（或等于当前节点）→ 当前节点即为 LCA

## 复杂度
- 时间：O(n)，每个节点访问一次
- 空间：O(h)~O(n)，h 为树高（递归栈/队列）

## 易错点
- 空树特判 `if (!root) return`
- 层序遍历先记录 size 再遍历，否则队列变化
- 最小深度是到**叶子节点**的路径，不是空节点
- 统一迭代法中 nullptr 标记的节点需要再取一次栈顶
- **翻转二叉树不可用中序遍历**，交换后会处理两次原左子树
- **构造二叉树**：后序最后一个为根，在中序中找根分割左右子树，区间长度要对应
- **左叶子**判断需要父节点标记，不能只看当前节点
- **BST 验证**：不能只比较父子节点，要确保整个左子树都小于根
- **BST 众数**：相等时 cnt++，不等时 cnt=1（不是 cnt=0）
- **BST 删除双子节点**：找替换节点时注意处理边界情况

## 题目索引（代码与力扣链接）

### 深度优先遍历（前中后序）
- 144 二叉树的前序遍历 ― [代码](../../code/二叉树/144%20二叉树的前序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- 94 二叉树的中序遍历 ― [代码](../../code/二叉树/94%20二叉树的中序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- 145 二叉树的后序遍历 ― [代码](../../code/二叉树/145%20二叉树的后序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

### 广度优先遍历（层序及变体）
- 102 二叉树的层序遍历 ― [代码](../../code/二叉树/102%20二叉树的层序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- 107 二叉树的层序遍历 II ― [代码](../../code/二叉树/107%20二叉树的层序遍历%20II.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
- 199 二叉树的右视图 ― [代码](../../code/二叉树/199%20二叉树的右视图.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-right-side-view/)
- 637 二叉树的层平均值 ― [代码](../../code/二叉树/637%20二叉树的层平均值.cpp) | [LeetCode](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
- 429 N 叉树的层序遍历 ― [代码](../../code/二叉树/429%20N%20叉树的层序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
- 513 找树左下角的值 ― [代码](../../code/二叉树/513%20找树左下角的值.cpp) | [LeetCode](https://leetcode.cn/problems/find-bottom-left-tree-value/)

### 树的属性
- 101 对称二叉树 ― [代码](../../code/二叉树/101%20对称二叉树.cpp) | [LeetCode](https://leetcode.cn/problems/symmetric-tree/)
- 104 二叉树的最大深度 ― [代码](../../code/二叉树/104%20二叉树的最大深度.cpp) | [LeetCode](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
- 111 二叉树的最小深度 ― [代码](../../code/二叉树/111%20二叉树的最小深度.cpp) | [LeetCode](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
- 222 完全二叉树的节点个数 ― [代码](../../code/二叉树/222%20完全二叉树的节点个数.cpp) | [LeetCode](https://leetcode.cn/problems/count-complete-tree-nodes/)
- 110 平衡二叉树 ― [代码](../../code/二叉树/110%20平衡二叉树.cpp) | [LeetCode](https://leetcode.cn/problems/balanced-binary-tree/)
- 404 左叶子之和 ― [代码](../../code/二叉树/404%20左叶子之和.cpp) | [LeetCode](https://leetcode.cn/problems/sum-of-left-leaves/)

### 树的修改与构造
- 226 翻转二叉树 ― [代码](../../code/二叉树/226%20翻转二叉树.cpp) | [LeetCode](https://leetcode.cn/problems/invert-binary-tree/)
- 106 从中序与后序遍历序列构造二叉树 ― [代码](../../code/二叉树/106%20从中序与后序遍历序列构造二叉树.cpp) | [LeetCode](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
- 654 最大二叉树 ― [代码](../../code/二叉树/654%20最大二叉树.cpp) | [LeetCode](https://leetcode.cn/problems/maximum-binary-tree/)

### 路径问题
- 257 二叉树的所有路径 ― [代码](../../code/二叉树/257%20二叉树的所有路径.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-paths/)
- 112 路径总和 ― [代码](../../code/二叉树/112%20路径总和.cpp) | [LeetCode](https://leetcode.cn/problems/path-sum/)

### 二叉搜索树（BST）
- 700 二叉搜索树中的搜索 ― [代码](../../code/二叉树/700%20二叉搜索树中的搜索.cpp) | [LeetCode](https://leetcode.cn/problems/search-in-a-binary-search-tree/)
- 98 验证二叉搜索树 ― [代码](../../code/二叉树/98%20验证二叉搜索树.cpp) | [LeetCode](https://leetcode.cn/problems/validate-binary-search-tree/)
- 530 二叉搜索树的最小绝对差 ― [代码](../../code/二叉树/530%20二叉搜索树的最小绝对差.cpp) | [LeetCode](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)
- 501 二叉搜索树中的众数 ― [代码](../../code/二叉树/501%20二叉搜索树中的众数.cpp) | [LeetCode](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)
- 701 二叉搜索树中的插入操作 ― [代码](../../code/二叉树/701%20二叉搜索树中的插入操作.cpp) | [LeetCode](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)
- 450 删除二叉搜索树中的节点 ― [代码](../../code/二叉树/450%20删除二叉搜索树中的节点.cpp) | [LeetCode](https://leetcode.cn/problems/delete-node-in-a-bst/)

### 公共祖先
- 236 二叉树的最近公共祖先 ― [代码](../../code/二叉树/236%20二叉树的最近公共祖先.cpp) | [LeetCode](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
- 235 二叉搜索树的最近公共祖先 ― [代码](../../code/二叉树/235%20二叉搜索树的最近公共祖先.cpp) | [LeetCode](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)
