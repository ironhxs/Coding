# 二叉树｜总结

关键：递归三要素、统一迭代法、层序遍历模板、DFS vs BFS 选择。

## 遍历方式

### 递归遍历（DFS）
递归三要素（代码随想录精华）：
1. **确定递归函数的参数和返回值**
2. **确定终止条件**
3. **确定单层递归的逻辑**

```cpp
// 前序：中-左-右
void preorder(TreeNode* node) {
    if (!node) return;
    visit(node);           // 中
    preorder(node->left);  // 左
    preorder(node->right); // 右
}
// 中序：左-中-右 | 后序：左-右-中（调整 visit 位置即可）
```

### 统一迭代法（栈 + nullptr 标记）
核心思想：用 nullptr 标记待处理节点，实现前中后序统一模板。

```cpp
// 入栈顺序（栈是后进先出，所以反着写）
// 前序(中左右): 右-左-中-nullptr
// 中序(左中右): 右-中-nullptr-左
// 后序(左右中): 中-nullptr-右-左
while (!st.empty()) {
    auto node = st.top(); st.pop();
    if (node) {
        // 按顺序入栈（反向）
        if (node->right) st.push(node->right);
        st.push(node);
        st.push(nullptr);  // 标记
        if (node->left) st.push(node->left);
    } else {
        node = st.top(); st.pop();
        ret.push_back(node->val);  // 处理
    }
}
```

### 层序遍历（BFS）
模板（代码随想录精华）：一道模板可以解决 10+ 道层序变体题。

```cpp
queue<TreeNode*> que;
que.push(root);
while (!que.empty()) {
    int size = que.size();  // 关键：记录当前层节点数
    for (int i = 0; i < size; i++) {
        auto node = que.front(); que.pop();
        // 处理当前节点
        if (node->left) que.push(node->left);
        if (node->right) que.push(node->right);
    }
    // 一层处理完毕
}
```

## DFS vs BFS 选择

| 场景 | 选择 | 原因 |
|------|------|------|
| 需要逐层处理 | BFS | 天然按层分隔 |
| 求深度/路径 | DFS | 递归天然记录路径 |
| 验证结构性质 | 取决于题目 | 对称性用递归，层级用 BFS |
| 右视图/左视图 | BFS | 每层取边界元素 |

## 复杂度
- 时间：O(n)，每个节点访问一次
- 空间：O(h)~O(n)，h 为树高（递归栈/队列）

## 易错点
- 空树特判 `if (!root) return`
- 层序遍历先记录 size 再遍历，否则队列变化
- 最小深度是到**叶子节点**的路径，不是空节点
- 统一迭代法中 nullptr 标记的节点需要再取一次栈顶

## 题目索引（代码与力扣链接）

### 深度优先遍历（前中后序）
- 144 二叉树的前序遍历 ― [代码](../../code/二叉树/144%20二叉树的前序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- 94 二叉树的中序遍历 ― [代码](../../code/二叉树/94%20二叉树的中序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- 145 二叉树的后序遍历 ― [代码](../../code/二叉树/145%20二叉树的后序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

### 广度优先遍历（层序及变体）
- 102 二叉树的层序遍历 ― [代码](../../code/二叉树/102%20二叉树的层序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
- 107 二叉树的层序遍历 II ― [代码](../../code/二叉树/107%20二叉树的层序遍历%20II.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
- 199 二叉树的右视图 ― [代码](../../code/二叉树/199%20二叉树的右视图.cpp) | [LeetCode](https://leetcode.cn/problems/binary-tree-right-side-view/)
- 637 二叉树的层平均值 ― [代码](../../code/二叉树/637%20二叉树的层平均值.cpp) | [LeetCode](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
- 429 N 叉树的层序遍历 ― [代码](../../code/二叉树/429%20N%20叉树的层序遍历.cpp) | [LeetCode](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
- 111 二叉树的最小深度 ― [代码](../../code/二叉树/111%20二叉树的最小深度.cpp) | [LeetCode](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
