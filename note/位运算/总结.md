# 位运算｜总结

先记住经典恒等式，再在题里“按位模拟”。

## 模板（本仓风格）

1) 计数位 1（Brian Kernighan）
```cpp
int popcount(unsigned x){
    int cnt = 0;
    while (x){ x &= (x - 1); ++cnt; }
    return cnt;
}
```

2) 不用 + 号做加法
```cpp
int add(int a, int b){
    while (b){
        unsigned carry = (unsigned)(a & b) << 1;
        a ^= b; b = (int)carry;
    }
    return a;
}
```

3) 只出现一次（异或汇总）
```cpp
int singleNumber(const vector<int>& a){
    int x = 0; for (int v: a) x ^= v; return x;
}
```

4) 子集枚举（按位掩码）
```cpp
for (int s = sub; s; s = (s - 1) & sub){
    // use s
}
```

## 复杂度
- 位操作单次 O(1)
- popcount：O(k)（k 为 1 的个数）
- XOR 汇总：O(n)
- 子集枚举：O(2^{|sub|})

## 题目索引（代码与力扣链接）
- 191 位1的个数 — [代码](../../code/位运算/191%20位1的个数.cpp) | [LeetCode](https://leetcode.cn/problems/number-of-1-bits/)
- 136 只出现一次的数字 — [代码](../../code/位运算/136%20只出现一次的数字.cpp) | [LeetCode](https://leetcode.cn/problems/single-number/)
- 137 只出现一次的数字 II — [代码](../../code/位运算/137%20只出现一次的数字%20II.cpp) | [LeetCode](https://leetcode.cn/problems/single-number-ii/)
- 260 只出现一次的数字 III — [代码](../../code/位运算/260%20只出现一次的数字%20III.cpp) | [LeetCode](https://leetcode.cn/problems/single-number-iii/)
- 268 丢失的数字 — [代码](../../code/位运算/268%20丢失的数字.cpp) | [LeetCode](https://leetcode.cn/problems/missing-number/)
- 371 两整数之和 — [代码](../../code/位运算/371%20两整数之和.cpp) | [LeetCode](https://leetcode.cn/problems/sum-of-two-integers/)
- 461 汉明距离 — [代码](../../code/位运算/461%20汉明距离.cpp) | [LeetCode](https://leetcode.cn/problems/hamming-distance/)
- LCR 003 比特位计数 — [代码](../../code/位运算/LCR%20003%20比特位计数.cpp) | [LeetCode](https://leetcode.cn/problems/w3tCBm/)
- 面试题 01.01 判定字符是否唯一 — [代码](../../code/位运算/面试题%2001.01%20判定字符是否唯一.cpp) | [LeetCode](https://leetcode.cn/problems/is-unique-lcci/)
- 面试题 17.19 消失的两个数字 — [代码](../../code/位运算/面试题%2017.19%20消失的两个数字.cpp) | [LeetCode](https://leetcode.cn/problems/missing-two-lcci/)

