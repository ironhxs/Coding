# 二分查找｜总结

使用场景：数组有序或“答案空间”可单调判断（check(mid)）。

## 常用模板（按本仓风格）

1) 闭区间 [left, right]，查存在性/精确位置
```cpp
# include <vector>
using namespace std;
class Solution {
public:
    int search(vector<int>& nums, int target) {
        auto left = nums.begin(), right = nums.end() - 1;
        while (left <= right) {
            auto mid = left + (right - left) / 2; // 防溢出
            if (*mid < target) left = mid + 1;
            else if (*mid > target) right = mid - 1;
            else return static_cast<int>(mid - nums.begin());
        }
        return -1;
    }
};
```

2) 左闭右开 [left, right)，lower_bound 风格（找第一个 >= target）
```cpp
# include <vector>
using namespace std;
// 返回第一个 >= target 的迭代器（可能等于 nums.end()）
auto lower_bound_it = [](vector<int>& nums, int target){
    auto left = nums.begin(), right = nums.end();
    while (left < right) {
        auto mid = left + (right - left) / 2;
        if (*mid >= target) right = mid; // 往左逼近
        else left = mid + 1;
    }
    return left;
};
```

3) 右端点模板（upper_bound 风格：返回第一个 > target 的位置，再减一得到“最后一个 <= target”）
```cpp
# include <vector>
using namespace std;
auto rightmost_leq_it = [](vector<int>& nums, int target){
    auto left = nums.begin(), right = nums.end();
    while (left < right) {
        auto mid = left + (right - left) / 2;
        if (*mid > target) right = mid; // 收缩右侧
        else left = mid + 1;           // 允许等于，向右逼近
    }
    return left==nums.begin()? nums.end() : left-1; // 若全部 > target，返回 end() 表示未找到
};
```

二分答案（可行性判定）：定义 `bool check(x)`，若 `check(mid)` 为真则向可能更优的一侧收缩，否则反向收缩。

## 复杂度
- 时间：O(log n)
- 空间：O(1)

## 易错点
- 必须跨过 mid 更新，避免死循环（`left = mid + 1` / `right = mid - 1`）
- `mid = left + (right - left) / 2` 防止溢出
- 找边界时，退出后 `left/right` 的含义与题意匹配

## 代表题（本目录）
- 704、35、34、69、153、162、852、LCR173

## 题目索引（代码与力扣链接）
- 704 二分查找 — [代码](../../code/二分查找/704.二分查找.cpp) | [LeetCode](https://leetcode.cn/problems/binary-search/)
- 35 搜索插入位置 — [代码](../../code/二分查找/35%20搜索插入位置.cpp) | [LeetCode](https://leetcode.cn/problems/search-insert-position/)
- 34 在排序数组中查找元素的第一个和最后一个位置 — [代码](../../code/二分查找/34在排序数组中查找元素的第一个和最后一个位置.cpp) | [LeetCode](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
- 69 x 的平方根 — [代码](../../code/二分查找/69%20x%20的平方根.cpp) | [LeetCode](https://leetcode.cn/problems/sqrtx/)
- 153 寻找旋转排序数组中的最小值 — [代码](../../code/二分查找/153%20寻找旋转排序数组中的最小值.cpp) | [LeetCode](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
- 162 寻找峰值 — [代码](../../code/二分查找/162%20寻找峰值.cpp) | [LeetCode](https://leetcode.cn/problems/find-peak-element/)
- 852 山脉数组的峰顶索引 — [代码](../../code/二分查找/852%20山脉数组的峰顶索引.cpp) | [LeetCode](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)
- LCR 173 点名 — [代码](../../code/二分查找/LCR%20173%20点名.cpp) | [LeetCode](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

