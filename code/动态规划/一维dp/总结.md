# 动态规划 · 一维dp 总结（我的刷题笔记）

我做一维 DP 的顺序：定“状态”→ 写“转移”→ 明“边界/初值”→ 能否“滚动优化”。

## 常见模型与我的模板
1) 线性递推（爬楼梯/泰波那契/三步问题）
<augment_code_snippet path="Coding/code/动态规划/一维dp/总结.md" mode="EXCERPT">
````cpp
long long tribonacci(int n){
    if(n==0) return 0;
    if(n==1||n==2) return 1;
    long long a=0,b=1,c=1; // T0,T1,T2
    for(int i=3;i<=n;++i){ long long d=a+b+c; a=b; b=c; c=d; }
    return c; // O(n) 时间，O(1) 空间
}
````
</augment_code_snippet>

2) 解码方法（字符串 DP）
<augment_code_snippet path="Coding/code/动态规划/一维dp/总结.md" mode="EXCERPT">
````cpp
int numDecodings(const string& s){
    int n=(int)s.size(); if(!n||s[0]=='0') return 0;
    vector<int> dp(n+1); dp[0]=1; dp[1]=1;
    for(int i=2;i<=n;++i){
        if(s[i-1] != '0') dp[i] += dp[i-1];
        int x=(s[i-2]-'0')*10 + (s[i-1]-'0');
        if(10<=x && x<=26) dp[i] += dp[i-2];
    }
    return dp[n]; // O(n) 时间，O(n) 空间（可滚动）
}
````
</augment_code_snippet>

## 复杂度
- 线性递推：O(n) 时间，O(1) 空间
- 解码方法：O(n) 时间，O(1)/O(n) 空间（看是否滚动）

## 我容易错的点
- 解码方法中 '0' 的处理最容易翻车：只能与前一位构成 10 或 20 才合法
- 下标对应：dp[i] 和 s[i-1] 的映射要写清
- 有时题目需要取模，提前规划好类型与取模点

## 代表题（我在本目录已做）
- 746、1137、91、面试题 08.01
